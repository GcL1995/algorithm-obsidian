#欧拉路径
>背景：
>	哥尼斯堡七桥问题：是否存在一条路径，从某个地方开始走，每个桥恰好走一次
>
>欧拉路径: 图G中的一条路径若包括每个边恰好一次，则其为欧拉路径
>欧拉回路: 存不存在一条环路，每条边恰好走一次，其实就是终点就是起点的欧拉路径
一、无向图
   1 存在欧拉路径的充要条件 : *度数为奇数的点只能有0或2个*
		**必要性**:
		显然的，假设存在这样的一条路径，那么中间点的度数必然是偶数，因为要出去一次还要进来一次，而起点和终点如果相同，那么也是偶数；如果不同，那么除了出n次进n次之外，起点要多出去一次，终点要多进来一次。			
		**充分性**：
		满足度数为奇数的点的话，我们可以通过dfs构造出来一个这样的路径，
		我们从2个奇数点之一开始dfs，因为只剩下一个点的度数为奇数，那么必然在这个奇数点停止，然后就要开始回溯，回溯的每一个点的度数都是偶数，那么必然每个回溯点都是这条路径与一个环的交点，这样我们就能够构造出来一个欧拉路径。
		*这条欧拉路径是一个起点到终点的路径加若干个和该路径相交的环构成的*
   2 存在欧拉回路的充要条件 : 度数为奇数的点只能有0个  
> 
二、有向图
   1 存在欧拉路径的充要条件 : *要么所有点的出度均 = 入度*；
                              要么除了两个点之外，其余所有点的出度=入度 剩余的两个点:一个满足出度-入度=1(起点) 一个满足入度-出度=1(终点)
   2 存在欧拉回路的充要条件 : *所有点的出度均等于入度*
   ***类似于无向图的证明***
三、dfs求欧拉路径
	在思考中不妨简化为一条路径+一个环
	在证明定理的充分性的同时我们已经构造出来了一个欧拉路径
	但是需要注意的是如果在dfs到该点的时候便直接记录记录得到的路径就是首先是从起点到终点，然后后面跟着若干个环，这样是不能直接作为欧拉路径输出的。
	我们可以选择*在每次遍历这条边连接的点之后，再将这条边添加到路径中*，这样第一次加入到路径中的一定是终点， 最后一个加入到路径中的一定是起点。同时加入一个点，意味着在这条欧拉路径中所有的u的后续节点已经添加到路径中了(因为u的所有边已经遍历过了)，这样我们就得到了一条欧拉路径的反路径。
	不同于一般的dfs， 欧拉路径中如果使用边判重，那么会使得算法的*时间复杂度为o(m * m)*， 这一点可以考虑只有一个点，m条自环的特殊图，可以看到，每次看到需要遍历m次， 每次判断m条边是否已经被遍历。
	为了让算法的时间复杂度降到o(n + m)， 那么需要*通过删边的操作来优化*
	
[1184. 欧拉回路](https://www.acwing.com/problem/content/description/1186/)
>题目大意：
>type = 1 无向图 2 有向图
>n个点
>m条边
>求是否存在欧拉回路，如果存在输出该欧拉回路

~~~c++
/*
i. 判断是否存在欧拉回路
ii. 输出欧拉回路

判断欧拉回路定理
dfs如果求得最后的欧拉回路边数小于m则表示存在孤立边

dfs的时候需要删除边，每次遍历到一个点便删除掉，这样可以用h[u] = ne[h[u]]来删除， 同时为了让后面删除的边影响前面删除的边，使用while(~h[u])而不用通常的遍历邻接表的for循环
*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, M = 400010; 

int type, n, m; 
int h[N], e[M], ne[M], idx;
int din[N], dout[N];
int ans[M / 2], cnt;
bool used[M]; // 无向图必须加入标记，标记为删除则不再添加

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++; 
}

void dfs(int u) {
    while (~h[u]) { //优化dfs为o(m) 不优化则时间复杂度为o(m * m)
        int i = h[u]; 
        if (used[i]) { // 如果是无向图，那么存在遍历到该点，但是该点已经被标记为删除
            h[u] = ne[i]; // 删除边
            continue;
        }
        
        if (type & 1) used[i ^ 1] = true;
        used[i] = true;
        h[u] = ne[i]; //删除边
        
        int t; // 用t记录当前边，这里的t需要根据idx值，也就是第几条边来特别判断
        if (type & 1) {
            t = i / 2 + 1;
            if (i & 1) t = -t; 
        } else t = i + 1; 
        
        dfs(e[i]); 
        ans[cnt ++] = t;// 遍历完i指向的边之后，再将该条边加入到路径中
    }
}

int main() {
    cin >> type >> n >> m; 
    memset(h, -1, sizeof h); 
    
    for (int i = 1; i <= m; i ++ ) {
        int a, b; 
        cin >> a >> b;
        add(a, b);
        dout[a] ++, din[b] ++; // 无向图， 入度和出度相加为真实度数
        if (type & 1) add(b, a); // 无向图需要加入两条边，一条边使用后，另一条边需要做标记
    }
    
    if (type & 1) {
        for (int i = 1; i <= n; i ++ ) {
            if (dout[i] + din[i] & 1) {
                cout << "NO" << endl;
                return 0; 
            }
        }
    } else {
        for (int i = 1; i <= n; i ++ ) {
            if (dout[i] != din[i]) {
                cout << "NO" << endl; 
                return 0; 
            }
        }
    }
    
    for (int i = 1; i <= n; i ++ ) {
        if (dout[i] + din[i]) {
            dfs(i);
            break; 
        } 
    }
    
    if (cnt < m) cout << "NO" << endl; 
    else {
        cout << "YES" << endl;
        for (int i = m - 1; i >= 0; i -- ) cout << ans[i] << ' ';
    }
}
~~~
## 周赛
[[WC 270. 从二叉树一个节点到另一个节点每一步的方向]]
[[CF 1511D. Min Cost String]] 最小综合子串问题
[[LC 753. 破解保险箱]] 最小综合子串问题
