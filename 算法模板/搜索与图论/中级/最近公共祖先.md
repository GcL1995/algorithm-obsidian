#最近公共祖先
# 向上标记法
[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
#DFS
~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
/*
dfs记录每个点的父节点

向上遍历p节点的所有祖宗节点，并标记
向上遍历q节点的所有祖宗节点，并找到第一个被标记的点即为最近公共祖先
*/
class Solution {
public:
    unordered_map<int, TreeNode*> fa;
    unordered_set<int> S; 
    void dfs(TreeNode* u) {
        if (u -> left != NULL) {
            fa[u -> left -> val] = u;
            dfs(u -> left);
        }
        if (u -> right != NULL) {
            fa[u -> right -> val] = u;
            dfs(u -> right); 
        }
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        dfs(root); 

        while (fa[p -> val] != NULL) {
            S.insert(p -> val); 
            p = fa[p -> val];
        }

        while (fa[q -> val] != NULL && S.find(q -> val) == S.end()) {
            q = fa[q -> val]; 
        } 
        return q;
    }
};
~~~

### WC 271C
#### [2096. 从二叉树一个节点到另一个节点每一步的方向](https://leetcode-cn.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/)
#DFS #最近公共祖先 
~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
/*
思路：
向上标记法获取最近公共祖先
然后求得最近公共祖先到两个值的路径即可

为了代码的简单，可以在向上标记的过程中求路径
*/
class Solution {
public:
    unordered_map<int, TreeNode*> fa;
    unordered_map<int, int> depth; 

    void dfs(TreeNode* u) {
        if (u -> left != NULL) {
            fa[u -> left -> val] = u;
            dfs(u -> left); 
        }

        if (u -> right != NULL) {
            fa[u -> right -> val] = u;
            dfs(u -> right); 
        }
    }
    string getDirections(TreeNode* root, int startValue, int destValue) {
        dfs(root); //获取val -> father 的映射

        int v = startValue, d = 1;
        while (fa[v] != nullptr) {//向上标记法 同时求得层数 定义 startValue的层数为1 祖宗节点依次加一
            depth[v] = d ++; 
            v = fa[v] -> val;
        }  
        depth[v] = d; //根节点

        v = destValue;
        string right = "";
        while (depth[v] == 0) { // 向上标记法 求最近公共祖先 同时更新right
            TreeNode* t = fa[v];
            if (t -> left != nullptr && t -> left -> val == v) right.push_back('L');
            else right.push_back('R');
            v  = t -> val;
        }
        reverse(right.begin(), right.end()); 
        
        string left = "";
        d = depth[v];//获取最近公共祖先的层数

        while (d -- != 1) left.push_back('U'); 

        return left + right; 
    }
};
~~~
# 倍增法
>fa[i, j] 表示 从i开始向上走2^j步所能走到的节点
>depth[i] 表示 i的层数
>

[acwing 1172. 祖孙询问](https://www.acwing.com/activity/content/code/content/154772/)
~~~c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 40010, M = N * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][16];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k <= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
	// 将 a 放到 b 同一层
	// 类似于 求x的二进制表示的思想，先找到小于x的最大2^k，再减去2^k
    for (int k = 15; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
    if (a == b) return a;
	// 找到最近公共祖先的下一个点
	// 类似于 求x的二进制表示的思想，先找到小于x的最大2^k，再减去2^k
    for (int k = 15; k >= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int main()
{
    scanf("%d", &n);
    int root = 0;
    memset(h, -1, sizeof h);

    for (int i = 0; i < n; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (b == -1) root = a;
        else add(a, b), add(b, a);
    }

    bfs(root);

    scanf("%d", &m);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        int p = lca(a, b);
        if (p == a) puts("1");
        else if (p == b) puts("2");
        else puts("0");
    }

    return 0;
}
~~~

## 相关题目
[[LC 1483. 树节点的第 K 个祖先]]