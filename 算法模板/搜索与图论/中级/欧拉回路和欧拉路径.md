#欧拉路径
>欧拉路径: 图G中的一条路径若包括每个边恰好一次，则其为欧拉路径
>欧拉回路: 终点就是起点的欧拉路径
一、无向图
   1 存在欧拉路径的充要条件 : 度数为奇数的点只能有0或2个
   2 存在欧拉回路的充要条件 : 度数为奇数的点只能有0个
二、有向图
   1 存在欧拉路径的充要条件 : 要么所有点的出度均 = 入度；
                              要么除了两个点之外，其余所有点的出度=入度 剩余的两个点:一个满足出度-入度=1(起点) 一个满足入度-出度=1(终点)
   2 存在欧拉回路的充要条件 : 所有点的出度均等于入度
## 周赛
[[WC 270. 从二叉树一个节点到另一个节点每一步的方向#D]]
#模板题 
~~~c++
/*
出度 == 入度 + 1的点为起点 
dfs(start) 即可获得路径

dfs获得欧拉路径的正确性
dfs第一次遍历获得的路径一定是从顶点到终点的路径(中间可能有环)
随后每一次回溯都对应一个环
所以如果按照dfs遍历的顺序获得的路径不能保证是欧拉路径

但是如果是遍历完之后获得的路径，那么在这个点之后的所有的环都已经被遍历过了
可以确保是欧拉路径的反转
*/
class Solution {
public:
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        unordered_map<int, int> indeg, deg; 
        unordered_map<int, vector<int>> edges;

        for (vector<int> pair: pairs) {
            int x = pair[0], y = pair[1];
            deg[x] ++;
            indeg[y] ++;
            edges[x].push_back(y); 
        }

        int start = pairs[0][0];
        for (auto &[x, d]: deg) {
            if (d == indeg[x] + 1) {
                start = x;
                break;
            }
        }

        vector<vector<int>> ans;

        function<void(int)> dfs = [&](int u) {
            while (!edges[u].empty()) {
                int v = edges[u].back();
                edges[u].pop_back();
                dfs(v);
                ans.push_back({u, v});
            }
        };

        dfs(start); 
        reverse(ans.begin(), ans.end()); 
        return ans; 
    }
};
~~~

   