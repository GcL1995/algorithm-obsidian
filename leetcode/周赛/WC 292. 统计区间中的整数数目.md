#### [6066. 统计区间中的整数数目](https://leetcode.cn/problems/count-integers-in-intervals/)
#动态开点线段树 #线段树
> 题目大意：
> 实现一种数据结构
> i. 能够添加区间
> ii. 能够查询至少出现在其中一个区间的数字个数

~~~c++
/*
i. 线段树 动态开点
ii. 需要修改，不需要pushdown

*/
const int N = 100010, INF = 1e9;
struct Node {
    int l, r;
    int cnt;
    int ln, rn; 
} tr[21 * N];
int idx;

void pushup(int u) {
    tr[u].cnt = tr[tr[u].ln].cnt + tr[tr[u].rn].cnt;
}

void modify(int u, int left, int right) {
    if (tr[u].cnt == tr[u].r - tr[u].l + 1) return; // 当前区间已经完全覆盖，修改不会改变状态
    if (tr[u].l >= left && tr[u].r <= right) { // 当前区间将被完全覆盖，直接修改，同时不需要pushdown
        tr[u].cnt = tr[u].r - tr[u].l + 1;
    } else { // 需要修改子区间
        int mid = tr[u].l + tr[u].r >> 1; 
        if (tr[u].ln == 0) {// 需要动态开左子树
            tr[u].ln = ++ idx;
            tr[idx] = {tr[u].l, mid};
        }
        if (tr[u].rn == 0) {// 需要动态开右子树
            tr[u].rn = ++ idx;
            tr[idx] = {mid + 1, tr[u].r};
        }
        if (left <= mid) modify(tr[u].ln, left, right);
        if (right > mid) modify(tr[u].rn, left, right);
        pushup(u);
    }
}

class CountIntervals {
public:
    CountIntervals() {
        memset(tr, 0, sizeof tr);
        idx = 0; 
        tr[++ idx] = {1, INF, 0};
    }
    
    void add(int left, int right) {
        modify(1, left, right);
    }
    
    int count() {
        return tr[1].cnt;
    }
};

/**
 * Your CountIntervals object will be instantiated and called as such:
 * CountIntervals* obj = new CountIntervals();
 * obj->add(left,right);
 * int param_2 = obj->count();
 */
~~~