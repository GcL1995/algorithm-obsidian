#### [1889. 装包裹的最小浪费空间](https://leetcode.cn/problems/minimum-space-wasted-from-packaging/)
#二分 #前缀和 #贪心 #LC2200 
~~~c++
/*
i. sum(boxes[j].size()) <= 1e5, nlogn时间复杂度
ii. 排序packages，从小到大遍历每个box，二分查找比box[i]小的最大的packages[j]，累加浪费空间

*/
typedef long long LL;
const int N = 100010, mod = 1e9 + 7;
const LL INF = 1e18;
LL s[N]; 

class Solution {
public:
    int minWastedSpace(vector<int>& packages, vector<vector<int>>& boxes) {
        sort(packages.begin(), packages.end());
        int n = packages.size(); 
        for (int i = 1;i <= n; i ++ ) s[i] = s[i - 1] + packages[i - 1];
        LL ans = INF;
        for (auto &box: boxes) {
            int pre = -1;
            LL curr = 0; 
            int m = box.size(); 
            sort(box.begin(), box.end());
            if (box[m - 1] < packages[n - 1]) continue;
            for (int i = 0; i < box.size(); i ++ ) {
                int u = upper_bound(packages.begin(), packages.end(), box[i]) - packages.begin() - 1;
                if (u <= pre) continue;
                curr = (curr + (LL)(u - pre) * box[i] - (s[u + 1] - s[pre + 1]));

                //printf("%d %d %d %d %lld\n",i, box[i], u, packages[u], curr);
                pre = u;
                if (pre >= n - 1) break;
            }
            //printf("========\n");
            ans = min(ans, curr);
        }
        if (ans == INF) return -1;
        return (int)(ans % mod);
    }
};
~~~