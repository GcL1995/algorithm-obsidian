#### [2025. 分割数组的最多方案数](https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/)

> 题目大意：
> 	选择改变数组a的一个位置为k，或者不做任何改变
> 	求将数组分割成左右两个子数组且两个子数组和相同的分割方式最多有几种

~~~c++
/*
i. 遍历每个改变的位置，需要o(1)的时间求出来满足的分割方式
ii. 可以使用map做记录， 两个map分别记录分割位置小于当前位置的和分割位置大于等于当前位置的
iii. 如果分割位置在改变位置之前，那么sum[1 - i] = (tot + d) / 2
如果分割位置在当前位置之后，那么sum[1 - i] = (tot - d) / 2;
*/
typedef long long LL;
class Solution {
public:
    int waysToPartition(vector<int>& nums, int k) {

        int n = nums.size(); 
        vector<LL> f(n + 2, 0); 
        for (int i = 1; i <= n; i ++ ) f[i] = f[i - 1] + nums[i - 1];
        
        unordered_map<LL, int> cntL; 
        unordered_map<LL, int> cntR;
        for (int i = 1; i <= n - 1; i ++ ) cntR[f[i]] ++;
        
        LL tot = f[n];
        int res = 0; 
        if (tot % 2 == 0) res = cntR[tot / 2];

        for (int i = 1; i <= n; i ++ ) {
            int d = k - nums[i - 1];
            if ((tot + d) % 2 == 0) res = max(res, cntL[(tot + d) / 2] + cntR[(tot - d) / 2]);
            
            cntL[f[i]] ++;
            cntR[f[i]] --;
        }

        return res; 
    }
};
~~~
