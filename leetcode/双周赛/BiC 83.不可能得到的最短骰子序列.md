#### [6131. 不可能得到的最短骰子序列](https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/)
#贪心 #构造题 
> 题目大意：
> 一个长度为n的数组，一个k面的骰子，骰子每个面分别从1到k， 数组中的数字也在这个范围内。
> 可以知道数组的长为x的子序列都能对应一中骰子扔x次的结果。
> 那反过来问最短的不能从数组中得到的骰子子序列是多长？
> 提示一：包含所有长度为1的骰子子序列意味着什么？包含所有的数。
> 提示二：包含所有长度为2的骰子子序列意味着什么？可以分成两半每个都包含所有的从1到k的数。
> 提示三：从提示一和提示二容易想到一种贪心策略，那就是只要包含所有数字，那么cnt ++, 然后清空再找。这样cnt长度的所有骰子子序列都能表示出来。
> 提示四：提示三找到的一定是最优解吗？换句话说，cnt + 1的骰子子序列表示不出来吗？
> 	我们可以构造一个长度为cnt + 1的骰子子序列。前cnt个一定存在一个数字只出现了一次，同时假设最后一段缺少的数字为x，那么前cnt，就分别选择那一段只出现一次的数字，最后一个选择x。这样的序列一定构造不出来。
> 提示五：提示三和提示四分别表示的贪心解的充分必要性。

~~~c++
class Solution {
public:
    int shortestSequence(vector<int>& rolls, int k) {
        set<int> S;
        int cnt = 0;
        for (auto &x: rolls) {
            S.insert(x);
            if (S.size() == k) {
                cnt ++;
                S.clear();
            }
        }
        return cnt + 1;
    }
};
~~~